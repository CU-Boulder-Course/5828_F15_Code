(number-of-ones [1 0 0 0 0 1])
(mod-zero? [25 5])
(mod-zero? 25 5)
(mod-zero? 25 6)
(require :reload 'test.prime)
(source prime?)
(prime? 100)
(require :reload 'test.prime)
(prime? 100)
(require :reload 'test.prime)
(prime? 100)
(prime? 101)
(prime? 1)
(prime? 2)
(require :reload 'test.prime)
(prime? 2)
(def fm (range 2 (+ (. Math sqrt 2) 1)))
fm
(require :reload 'test.prime)
(prime? 2)
(prime? 3)
(prime? 101)
(def fm (range 2 (+ (. Math sqrt 3) 1)))
fm
(require :reload 'test.prime)
(prime? 2)
(prime? 3)
(prime? 100)
(prime? 101)
(prime? 1000000)
(prime? 10000000)
(prime? 10000001)
(prime? 10000002)
(. Math sqrt 2)
(. Math sqrt 3)
(range 2 (. Math sqrt 3))
(range 2 (. Math sqrt 4))
(range 2 3)
(range 2 4)
(range 2 5)
(range 2 101)
(map prime? (range 1 1000))
(convert-to-numbers (map prime? (range 1 1000)))
(number-of-ones (convert-to-numbers (map prime? (range 1 1000))))
(require :reload 'test.prime)
(count-primes
(count-primes 1000)
(count-primes 1001)
(prime? 1001)
(count-primes 1000)
(count-primes 10000)
(count-primes 100000)
(count-primes 1000)
(count-primes 2000)
(time (count-primes 2000))
(time (count-primes 1000))
(time (count-primes 10000))
(require :reload 'test.prime)
(time (count-primes 10000))
(time (count-primes 100000))
(require :reload 'test.prime)
(time (count-primes 1000))
(time (count-primes 10000))
(time (count-primes 100000))
(require :reload 'test.prime)
(prime? 2)
(prime? 3)
(if () true false)
(def r ())
r
(empty? r)
(require :reload 'test.prime)
(prime? 3)
(prime? 2)
(prime? 1)
(prime? 4)
(prime? 5)
(prime? 6)
(require :reload 'test.prime)
(prime? 6)
(require :reload 'test.prime)
(prime? 6)
(prime? 5)
(prime? 4)
(. Math sqrt 6)
(. Math sqrt 8)
(. Math sqrt 9)
(prime? 9)
(range 1 5 .5)
(range 1 5 2)
(range 1 5 0.5)
(require :reload 'test.prime)
(prime? 9)
(empty? (2 3))
(empty? [2 3])
(range 2 3 1)
(range 2 4 1)
(empty? (range 2 4 1))
(require :reload 'test.prime)
(prime? 9)
(require :reload 'test.prime)
(prime? 9)
(prime? 3)
(prime? 4)
(prime? 5)
(prime? 6)
(prime? 7)
(prime? 8)
(prime? 9)
(prime? 10)
(prime? 11)
(prime? 12)
(prime? 13)
(prime? 14)
(prime? 15)
(prime? 16)
(prime? 17)
(prime? 18)
(prime? 19)
(prime? 20)
(prime? 21)
(prime? 23)
(prime? 100)
(prime? 101)
(prime? 1001)
(prime? 100000)
(prime? 1000000)
(prime? 10000000)
(prime? 100000000)
(prime? 1000000000)
(prime? 1000000001)
(prime? 1000000002)
(require :reload 'test.prime)
(time (count-primes 1000))
(time (count-primes 100))
(time (count-primes 1))
(time (count-primes 10))
(count-primes 10)
(prime? 1)
(prime? 2)
(prime? 3)
(require :reload 'test.prime)
(prime? 1)
(prime? 2)
(prime? 3)
(prime? 4)
(prime? 5)
(prime? 6)
(prime? 7)
(prime? 8)
(prime? 9)
(prime? 10)
(time (count-primes 10))
(time (count-primes 100))
(time (count-primes 1000))
(time (count-primes 10000))
(require :reload 'test.prime)
(time (count-primes 10000))
(require :reload 'test.prime)
(time (count-primes 10000))
(time (count-primes 100000))
(time (count-primes 1000000))
(require :reload 'test.prime)
(time (count-primes 10))
(time (count-primes 100))
(time (count-primes 1000))
(time (count-primes 10000))
(time (count-primes 100000))
(time (count-primes 1000000))
(time (count-primes 100000))
(require :reload 'test.prime)
(time (count-primes 100000))
(time (count-primes-parallel 100000))
(time (count-primes 1000000))
(time (count-primes-parallel 1000000))
(= 2 2)
(= 2 3)
(require :reload 'test.prime)
(count-primes 10)
(count-primes 100)
(count-primes 1000)
(count-primes 10000)
(count-primes 100000)
(count-primes 1000000)
(time (count-primes 1000000))
(time (count-primes-parallel 1000000))
(require :reload 'test.prime)
(time (count-primes-speed 1000000))
(time (count-primes-speed-parallel 1000000))
(time (count-primes-speed-parallel 10000000))
(time (count-primes-speed 10000000))
(time (count-primes-speed-parallel 10000000))
(source time)
(source pmap)
(source map)
#{ 1 2 3 3 4 5 6 7 7 8 8 9 9 9 }
#{ 1 2 3 4 5 6 7 8 9 }
(source sort)
(sort [9 5 3])
(def pi 3.14159)
pi
(def x 5)
x
(+ x 10)
x
(def x 10)
x
(map + (range 10))
(map in (range 10))
(map inc (range 10))
(reduce + (map inc (range 10)))
(def lots-of-numbers-times-two (map (partial * 2) (range 0 10000000)))
(take 10 (drop 9000000 lots-of-numbers-times-two))
quit
def result (into [] (r/map (partial + 1) (r/filter even? (range 10000000)))))
(require '[clojure.core.reducers :as r])
(def result (into [] (r/map (partial + 1) (r/filter even? (range 10000000)))))
(count result)
(def result (into [] (r/map (partial + 1) (r/filter even? (range 100000000)))))
(def result (r/foldcat (r/map (partial + 1) (r/filter even? (range 100000000)))))
(source prime?)
(prime? 1001)
(prime? 1003)
(prime? 13)
(prime? 10000000)
(prime? 100000000)
(prime? 1000000000)
(prime? 10000000000)
(prime? 999999999999999)
(prime? 99999999999)
(prime? 99999999)
(prime? 9999999999999M)
(. Integer MAX)
(. Integer Max)
(. Integer MAX_VALUE)
(prime? 2147483647)
(take 10 (iterate inc 0))
(into [] (range 1000)))
(into [] (range 1000))
(def numbers (into [] (range 10000000)))
(count numbers)
(def primes (into [] (map prime? numbers)))
(count primes)
(first primes)
(require :reload 'primes.core)
(produce-range 10)
(def x (produce-range 10000000))
(count x)
(source reduce)
(exit)
(require :reload 'primes.core)
(def vals (produce-range 10000))
(count vals)
vals
(def pvals (find-primes vals))
pvals
(count pvals)
(require :reload 'primes.core)
(def tvals (convert-to-numbers pvals))
tvals
(count tvals)
(require :reload 'primes.core)
(sum tvals)
(require :reload 'primes.core)
(count-primes 10000)
(count-primes 100000)
(count-primes 1000000)
(count-primes 10000000)
(time (count-primes 10000000))
(time (count-primes 100000000))
(exit)
(source r/map)
(source r/fold)
(require :reload 'primes.core)
(time (count-primes-par 10000000))
(time (count-primes-par 100000000))
(exit)
(def sum (future (+ 1 2 3 4 5 6 7 8 9 10)))
sum
@sum
(deref sum)
(let [a (future (+ 1 2)) b (future (+ 3 4))] (+ @a @b))
(def meaning-of-life (promise))
(future (println "The meaning of life is:" @meaning-of-life))
(deliver meaning-of-life 42)
(exit)
(prime? 1001)
(prime? 13)
(exit)
(source prime?)
(source map)
(if (< 10 5) "not going to happen")
(if (< 10 50) "not going to happen")
(quit)
(final-value)
(exit)
(exit
)
(exit)
(count-value)
(exit)
(count-value)
(exit)
(counterr-value)
(counter-value)
(wake-them-up)
(counter-value)
(exit)
(counter-value)
(wake-them-up)
(counter-value)
(exit)
(wake-them-up)
(counter-value)
(exit)
@counter
@log
(wake-them-up)
@log
@counter
(exit)
@log
@counter
(wake-them-up)
@log
@counter
(count @log)
(exit)
(wake-them-up)
@log
(count @log)
(exit)
(wake-them-up)
@log
@counter
(exit
)
(exit)
@log
@counter
(wake-them-up)
@log
@counter
(exit)
(defn wait-then-inc [i] (do (Thread/sleep 2000) (inc i)))
(def counter (agent 0))
(send counter wait-then-inc)
@counter
(send counter wait-then-inc)
@counter
(defn wait-then-inc [i] (do (Thread/sleep 10000) (inc i)))
(send counter wait-then-inc)
(await counter)
@counter
(exit)
@counter
(wake-them-up)
@counter
@log
quit
@counter
@log
(wait-for-it)
@counter
@log
(wake-them-up)
@log
@counter
(reset)
@counter
@log
quit
(wake-them-up)
@log
@counter
(reset)
@log
@counter
(wake-them-up)
@log
@counter
(reset)
quit
(refresh)
@counter
(wake-them-up)
@log
(refresh)
@log
@counter
quit
